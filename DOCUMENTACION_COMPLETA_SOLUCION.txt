================================================================================
                    DOCUMENTACIÓN COMPLETA DE LA SOLUCIÓN TPI
                          Sistema de Gestión de Clientes y Pedidos
================================================================================

RESUMEN EJECUTIVO
================================================================================
Esta solución representa un sistema completo de gestión de clientes y pedidos 
implementado con .NET 8 y .NET 9, siguiendo una arquitectura en capas y 
ofreciendo múltiples interfaces de usuario para diferentes plataformas.

ARQUITECTURA DE LA SOLUCIÓN
================================================================================

La solución está organizada en 10 proyectos con arquitectura en capas:

1. CAPA DE DOMINIO (Domain Model)
   - Domain.Model: Entidades de negocio con validaciones

2. CAPA DE DATOS (Data Access Layer)
   - Data: Repositorios y contexto de Entity Framework

3. CAPA DE APLICACIÓN (Application Services)
   - Application.Services: Servicios de negocio
   - DTOs: Objetos de transferencia de datos

4. CAPA DE API (Web API)
   - WebAPI: API REST con endpoints mínimos

5. CAPA DE CLIENTES API
   - API.Clients: Clientes HTTP para consumir la API

6. CAPAS DE PRESENTACIÓN (Multiple UI)
   - WindowsForms: Aplicación de escritorio
   - Blazor.Server: Aplicación web server-side
   - Blazor.WebAssembly: Aplicación web client-side
   - MAUI: Aplicación multiplataforma (Android, iOS, Windows, macOS)

TECNOLOGÍAS Y FRAMEWORKS UTILIZADOS
================================================================================

BACKEND:
- .NET 8 (mayoría de proyectos)
- .NET 9 (Blazor WebAssembly y MAUI)
- Entity Framework Core con SQL Server
- ASP.NET Core Web API con endpoints mínimos
- Swagger/OpenAPI para documentación

FRONTEND:
- Windows Forms (.NET 8)
- Blazor Server (.NET 8)
- Blazor WebAssembly (.NET 9)
- .NET MAUI (.NET 9) - Android, iOS, Windows, macOS

INFRAESTRUCTURA:
- HTTP clients para comunicación API
- Bootstrap para estilos web
- Font Awesome para iconos
- CORS habilitado para WebAssembly

MODELO DE DATOS IMPLEMENTADO
================================================================================

ENTIDADES PRINCIPALES:

1. CLIENTE
   - Id (int, PK, auto-increment)
   - Nombre (string, requerido, max 100 caracteres)
   - Apellido (string, requerido, max 100 caracteres)
   - Email (string, requerido, único, max 255 caracteres, validado con regex)
   - PaisId (int, FK a Pais)
   - FechaAlta (DateTime, auto-asignado)
   - Relación: Cliente ? Pais (Many-to-One)

2. PAIS
   - Id (int, PK, auto-increment)
   - Nombre (string, requerido, único, max 100 caracteres)
   - Datos precargados: Argentina, Brasil, Chile, Uruguay, Paraguay

3. PRODUCTO
   - Id (int, PK, auto-increment)
   - Nombre (string, requerido, max 100 caracteres)
   - Descripcion (string, requerido, max 500 caracteres)
   - Precio (decimal(18,2), requerido)
   - Stock (int, requerido)
   - Datos precargados: 5 productos de tecnología

4. PEDIDO
   - Id (int, PK, auto-increment)
   - ClienteId (int, FK a Cliente)
   - FechaPedido (DateTime, requerido)
   - ItemsPedido (List<ItemPedido>, owned entity)
   - Relación: Pedido ? Cliente (Many-to-One)

5. ITEM_PEDIDO (Owned Entity)
   - ProductoId (int, FK a Producto)
   - PedidoId (int, FK a Pedido)
   - Cantidad (int, requerido, > 0)
   - PrecioUnitario (decimal(18,2), requerido)
   - Total (calculado: Cantidad * PrecioUnitario)
   - Relación: ItemPedido ? Producto (Many-to-One)

CARACTERÍSTICAS DEL MODELO DE DOMINIO:
- Encapsulación completa con propiedades privadas
- Validaciones en setters con excepciones descriptivas
- Navigation properties con backing fields para control de estado
- Inmutabilidad de constructores
- Métodos de dominio para operaciones de negocio

FUNCIONALIDADES IMPLEMENTADAS POR MÓDULO
================================================================================

MÓDULO CLIENTES (Todas las UIs):

OPERACIONES CRUD COMPLETAS:
? Crear Cliente
  - Validación de email único
  - Validación de formato de email con regex
  - Selección de país desde combo
  - Auto-asignación de fecha de alta

? Leer Cliente(s)
  - Listado completo con paginación visual
  - Búsqueda por ID
  - Búsqueda por criterios (nombre, apellido, email)
  - Incluye información del país asociado

? Actualizar Cliente
  - Validación de email único (excluyendo el actual)
  - Preserva fecha de alta original
  - Actualización de país

? Eliminar Cliente
  - Confirmación antes de eliminar
  - Validación de integridad referencial

CARACTERÍSTICAS ESPECIALES:
- Búsqueda multi-criterio (texto busca en nombre, apellido y email)
- Validación de email en tiempo real
- Manejo de errores con mensajes descriptivos
- Refresh automático de listas después de operaciones

MÓDULO PAÍSES:

? Listado Completo
  - 5 países precargados en base de datos
  - Usado como lookup en formularios de cliente

? Consulta Individual
  - Endpoint GET por ID

MÓDULO PRODUCTOS:

? Listado Completo
  - 5 productos de tecnología precargados
  - Información completa: nombre, descripción, precio, stock

? Consulta Individual
  - Endpoint GET por ID
  - Usado en formularios de pedidos

MÓDULO PEDIDOS (WindowsForms únicamente):

? Crear Pedido
  - Selección de cliente desde combo
  - Fecha de pedido configurable
  - Gestión de items del pedido
  - Cálculo automático de totales

? Leer Pedido(s)
  - Listado con información del cliente
  - Detalle completo del pedido
  - Visualización de items y totales

? Actualizar Pedido
  - Modificación de fecha y cliente
  - Gestión completa de items
  - Recálculo de totales

? Eliminar Pedido
  - Confirmación antes de eliminar
  - Eliminación en cascada de items

GESTIÓN DE ITEMS DE PEDIDO:
? Agregar Item
  - Selección de producto desde combo
  - Auto-completado de precio del producto
  - Validación de cantidad > 0
  - Cálculo automático del total

? Modificar Item
  - No permite cambiar el producto (regla de negocio)
  - Permite modificar cantidad y precio unitario
  - Recálculo automático del total

? Eliminar Item
  - Confirmación antes de eliminar
  - Actualización de totales del pedido

DETALLES DE IMPLEMENTACIÓN POR CAPA
================================================================================

1. DOMAIN.MODEL (Capa de Dominio):

PATRÓN DOMAIN DRIVEN DESIGN:
- Entidades con comportamiento y validaciones
- Value objects implícitos (como Email validation)
- Agregados root (Cliente, Pedido)
- Encapsulación total con métodos Set explícitos

VALIDACIONES IMPLEMENTADAS:
- Cliente: Email formato válido, campos requeridos, PaisId > 0
- Pedido: ClienteId > 0, FechaPedido válida, colección de items
- ItemPedido: ProductoId > 0, Cantidad > 0, PrecioUnitario >= 0
- Producto: Nombre requerido, Precio >= 0, Stock >= 0
- Pais: Nombre requerido y único

NAVEGACIÓN ENTRE ENTIDADES:
- Navigation properties con backing fields privados
- Sincronización automática entre FKs y navigation properties
- Lazy loading habilitado

2. DATA (Capa de Acceso a Datos):

ENTITY FRAMEWORK CONFIGURATION:
- Fluent API completa para todas las entidades
- Índices únicos para Email (Cliente) y Nombre (Pais)
- Configuración de precision para decimales
- Owned entities para ItemPedido
- Data seeding para Paises y Productos

REPOSITORIOS IMPLEMENTADOS:
- ClienteRepository: CRUD + búsqueda por criterios + validación email único
- PedidoRepository: CRUD completo con items
- ProductoRepository: Read operations
- PaisRepository: Read operations

CARACTERÍSTICAS TÉCNICAS:
- Context con configuración automática desde appsettings.json
- EnsureCreated para desarrollo
- Transacciones implícitas de EF
- Include para eager loading de relaciones

3. APPLICATION.SERVICES (Capa de Servicios):

SERVICIOS DE APLICACIÓN:
- ClienteService: Orchestration de operaciones, validaciones de negocio
- PedidoService: Gestión completa de pedidos e items
- ProductoService: Consultas de productos
- PaisService: Consultas de países

CARACTERÍSTICAS:
- Mapeo entre Domain Models y DTOs
- Validaciones adicionales de negocio
- Manejo de excepciones con mensajes descriptivos
- Transaccionalidad implícita

4. DTOs (Data Transfer Objects):

OBJETOS DE TRANSFERENCIA:
- ClienteDTO: Incluye PaisNombre calculado
- PedidoDTO: Incluye ClienteNombre y lista de Items
- ItemPedidoDTO: Incluye ProductoNombre y Total calculado
- ProductoDTO: Mapping directo del dominio
- PaisDTO: Mapping directo del dominio
- ClienteCriteriaDTO: Para búsquedas parametrizadas

CARACTERÍSTICAS:
- Propiedades calculadas (NombreCompleto, Total)
- Optimización para serialización JSON
- Campos adicionales para UI (nombres de lookup)

5. WEBAPI (Capa de API REST):

ENDPOINTS IMPLEMENTADOS:

Clientes:
- GET /clientes ? Lista todos los clientes
- GET /clientes/{id} ? Cliente por ID
- GET /clientes/criteria?texto={texto} ? Búsqueda por criterios
- POST /clientes ? Crear cliente
- PUT /clientes ? Actualizar cliente
- DELETE /clientes/{id} ? Eliminar cliente

Países:
- GET /paises ? Lista todos los países
- GET /paises/{id} ? País por ID

Productos:
- GET /productos ? Lista todos los productos
- GET /productos/{id} ? Producto por ID

Pedidos:
- GET /pedidos ? Lista todos los pedidos
- GET /pedidos/{id} ? Pedido por ID
- POST /pedidos ? Crear pedido
- PUT /pedidos ? Actualizar pedido
- DELETE /pedidos/{id} ? Eliminar pedido

CARACTERÍSTICAS TÉCNICAS:
- Minimal APIs de .NET 8
- Swagger/OpenAPI automático
- CORS configurado para Blazor WebAssembly
- HTTP logging en desarrollo
- Content negotiation automático
- Status codes HTTP apropiados
- Manejo de errores con BadRequest/NotFound

6. API.CLIENTS (Clientes HTTP):

CLIENTES IMPLEMENTADOS:
- ClienteApiClient: Operaciones completas con manejo de errores
- PedidoApiClient: CRUD completo
- ProductoApiClient: Consultas
- PaisApiClient: Consultas

CARACTERÍSTICAS:
- HttpClient configurado con base address
- Headers de Accept para JSON
- Manejo completo de excepciones
- Timeouts y errores de red
- Serialización/deserialización automática JSON
- Escape de parámetros URL

7. WINDOWSFORMS (Aplicación de Escritorio):

FORMULARIOS IMPLEMENTADOS:

Home (Menú Principal):
- MenuStrip con navegación a Clientes y Pedidos
- Diseño MDI implícito

ClienteLista:
- DataGridView con todas las columnas
- Botones: Agregar, Modificar, Eliminar
- Doble click para editar
- Refresh automático después de operaciones

ClienteDetalle:
- Formulario modal para CRUD
- Validaciones con ErrorProvider
- ComboBox de países cargado dinámicamente
- Modos: Add/Update con campos condicionales

PedidoLista:
- DataGridView con información del cliente
- Columnas calculadas (cantidad items, total)
- Navegación a detalle del pedido

PedidoDetalle:
- Formulario complejo con DataGridView para items
- ComboBox de clientes
- Gestión completa de items con sub-formulario
- Cálculos automáticos de totales
- Validaciones de negocio

ItemPedidoDetalle:
- Sub-formulario para gestión de items
- ComboBox de productos con auto-completado de precio
- Validaciones de cantidad y precio
- Modo Update no permite cambiar producto

CARACTERÍSTICAS TÉCNICAS:
- Data binding bi-direccional
- Validaciones con ErrorProvider
- Manejo de excepciones con MessageBox
- Confirmaciones para eliminaciones
- Formateo de fechas y monedas
- Sincronización de datos local vs API

8. BLAZOR SERVER (Aplicación Web Server-Side):

COMPONENTES IMPLEMENTADOS:

Pages/Clientes.razor:
- Tabla responsive con Bootstrap
- Modales para CRUD
- Loading indicators
- Mensajes de éxito/error
- Confirmaciones JavaScript
- Icons de Font Awesome

Components/ClienteModal.razor:
- Modal reutilizable para Add/Edit
- Validaciones del lado cliente
- Select de países con binding
- Reseteo de formulario

Layout/_Host.cshtml:
- Layout principal con Bootstrap 5
- Referencias a CSS y JS
- Error boundaries para desarrollo/producción

CARACTERÍSTICAS TÉCNICAS:
- Server-side rendering con SignalR
- Interactive components
- JavaScript interop para confirmaciones
- CSS personalizado con Bootstrap
- Responsive design
- Manejo de estado en memoria del servidor

9. BLAZOR WEBASSEMBLY (Aplicación Web Client-Side):

COMPONENTES IMPLEMENTADOS:
(Misma funcionalidad que Blazor Server pero ejecutando en el cliente)

Pages/Clientes.razor:
- Funcionalidad idéntica a Blazor Server
- Ejecución 100% en el navegador

App.razor:
- Router con layout principal
- Página de Not Found
- Focus management

Program.cs:
- Configuración de HttpClient para API
- Registro de servicios para DI

CARACTERÍSTICAS TÉCNICAS:
- Ejecución en WebAssembly en el navegador
- HttpClient configurado para API externa
- Sin estado de servidor
- Descarga inicial más lenta, luego muy rápido
- Funciona offline después de carga inicial

10. MAUI (Aplicación Multiplataforma):

PÁGINAS IMPLEMENTADAS:

ClientesPage.xaml:
- CollectionView con DataTemplate complejo
- RefreshView para pull-to-refresh
- Botones de acción por cliente
- Loading indicator
- Layout responsive con Grid

ClienteDetallePage.xaml:
- Formulario completo con Entry fields
- Picker para países
- Validaciones visuales
- Botones de guardar/cancelar

MainPage.xaml:
- Página principal con navegación

AppShell.xaml:
- Shell navigation structure

VIEW MODELS:

ClientesViewModel:
- Patrón MVVM completo
- ObservableCollection para binding
- ICommand para acciones
- Async/await para operaciones API
- PropertyChanged notifications

ClienteDetalleViewModel:
- Binding bi-direccional con formulario
- Validaciones de negocio
- Navegación entre páginas

SERVICIOS:

ClienteApiClient (MAUI específico):
- HttpClient configurado para la plataforma
- Manejo de errores específico para móvil
- Serialización JSON optimizada

CARACTERÍSTICAS TÉCNICAS:
- Targets: Android, iOS, Windows, macOS
- Navegación Shell
- Binding bi-direccional
- Estilos nativos por plataforma
- Gestión de estado con ViewModels
- DisplayAlert para confirmaciones y errores

SEGURIDAD Y VALIDACIONES
================================================================================

VALIDACIONES DEL LADO SERVIDOR:
? Email único en base de datos
? Formato de email con expresiones regulares
? Campos requeridos en todas las entidades
? Validaciones de tipos de datos
? Validaciones de rangos (cantidad > 0, precio >= 0)

VALIDACIONES DEL LADO CLIENTE:
? Windows Forms: ErrorProvider
? Blazor: Validation components
? MAUI: Display alerts y visual feedback

MANEJO DE ERRORES:
? Excepciones tipadas con mensajes descriptivos
? HTTP status codes apropiados en API
? Manejo de timeouts y errores de red
? Logging de errores en desarrollo

PATRONES Y PRINCIPIOS APLICADOS
================================================================================

ARQUITECTURA:
- Layered Architecture (Capas)
- Separation of Concerns
- Dependency Inversion
- Single Responsibility Principle

PATRONES DE DISEÑO:
- Repository Pattern (Data access)
- Service Layer Pattern (Application Services)
- DTO Pattern (Data Transfer)
- API Client Pattern (HTTP communication)
- MVVM Pattern (MAUI)
- Component Pattern (Blazor)

PRÁCTICAS DE DESARROLLO:
- Domain-Driven Design principles
- Entity Framework Code First
- RESTful API design
- Responsive web design
- Cross-platform development

CONFIGURACIÓN Y DEPLOYMENT
================================================================================

BASES DE DATOS:
- SQL Server con connection string en appsettings.json
- Entity Framework migrations (Code First)
- Data seeding automático en desarrollo

CONFIGURACIÓN DE PROYECTOS:
- Multi-targeting (.NET 8 y .NET 9)
- Package references actualizadas
- Project references entre capas
- CORS configurado para cross-origin

PUERTOS Y URLS:
- WebAPI: http://localhost:5183
- Blazor Server: configuración por defecto
- Blazor WebAssembly: https://localhost:7170, http://localhost:5076

FUNCIONALIDADES AVANZADAS IMPLEMENTADAS
================================================================================

GESTIÓN DE ESTADO:
- Navigation properties sincronizadas
- Backing fields para control granular
- Owned entities para agregados complejos

OPTIMIZACIONES:
- Eager loading de relaciones necesarias
- DTOs optimizados para cada UI
- Caching implícito en clientes HTTP

EXPERIENCIA DE USUARIO:
- Loading indicators en todas las UIs
- Confirmaciones para acciones destructivas
- Mensajes de éxito y error informativos
- Auto-refresh después de operaciones
- Auto-completado de campos (precio de productos)

INTEROPERABILIDAD:
- API REST estándar consumible por cualquier cliente
- DTOs serializables a JSON
- CORS habilitado para clients externos

TESTING Y DEBUGGING:
- Swagger UI para testing de API
- HTTP logging en desarrollo
- Error boundaries en aplicaciones web
- Debug information en todas las capas

LIMITACIONES Y ÁREAS DE MEJORA
================================================================================

FUNCIONALIDADES NO IMPLEMENTADAS:
- Autenticación y autorización
- Paginación en listados grandes
- Filtrado avanzado en grillas
- Reportes y exports
- Auditoría de cambios
- Soft deletes
- Validaciones complejas de negocio
- Transacciones explícitas multi-entidad

MEJORAS TÉCNICAS PENDIENTES:
- Implementación de Unit of Work pattern
- Caching distribuido
- Background services
- Health checks
- Logging estructurado
- Metrics y monitoring
- Containerización con Docker
- CI/CD pipelines

OPTIMIZACIONES DE PERFORMANCE:
- Lazy loading configurable
- Paginación server-side
- Índices de base de datos optimizados
- Compresión de responses HTTP
- Bundling y minification de assets web

ESTADÍSTICAS DEL PROYECTO
================================================================================

LÍNEAS DE CÓDIGO APROXIMADAS:
- Domain.Model: ~800 líneas
- Data: ~600 líneas  
- Application.Services: ~400 líneas
- DTOs: ~200 líneas
- WebAPI: ~500 líneas
- API.Clients: ~400 líneas
- WindowsForms: ~2000 líneas
- Blazor.Server: ~800 líneas
- Blazor.WebAssembly: ~800 líneas
- MAUI: ~1200 líneas
TOTAL: ~7500+ líneas de código

ARCHIVOS PRINCIPALES:
- 47 archivos .cs
- 12 archivos .razor
- 8 archivos .xaml
- 10 archivos de proyecto .csproj
- Múltiples archivos de configuración y recursos

TECNOLOGÍAS INTEGRADAS:
- 4 frameworks diferentes de UI
- 2 versiones de .NET
- Entity Framework Core
- ASP.NET Core
- Bootstrap
- Font Awesome
- HTTP clients
- JSON serialization
- WebAssembly
- SignalR (Blazor Server)

================================================================================
Este documento representa un análisis completo de todas las funcionalidades
implementadas en la solución TPI, demostrando una arquitectura robusta y
escalable con múltiples tecnologías de Microsoft integradas de manera coherente.
================================================================================